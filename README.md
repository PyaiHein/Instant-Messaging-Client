# Instant-Messaging-Client

This project is created as an assignment for Network course at UC Davis.

This is a peer-to-peer messaging client that uses UDP to discover other clients, but will use TCP connections for transferring messages. The messaging client is able to maintain multiple simultaneous connections with other clients, and maintain a list of the clients available on the network. 

The instant messaging client starts up without any knowledge of currently available clients, but may have hints of previous clients. In order to discover other clients that are available on the local subnet, the instant messaging client broadcasts discovery messages over UDP. Online clients that receive this discovery message, respond with a unicast message to the client that sent the discovery broadcast. Clients that do not discover any other clients within the current timeout will send a discovery message after the elapsed time. The current timeout will double each time no reply messages are received, until it reaches the maximum timeout. The current timeout is reset to the initial value when a client transitions from one to zero discovered clients. When a client application is closing normally, it should broadcast a closing message. 

The messages between clients are sent via a TCP connection. A client will connect to another client on the port specified in the discovery or reply messages. Clients accept incoming messages initially and reply with a User Unavailable Message if communication is not desired. The TCP messaging is also capable of requesting and sending user lists; this allows the discovery of clients in other subnets without prior knowledge. When a user wishes to disconnect from a peer with an accepted communication path, the peer send a Discontinue Communication Message.

The authentication requests are sent to the trust anchor if specified or a trust anchor that has been discovered. If no trust anchor has been discovered, authentication requests are broadcast. Authentication requests that do not receive responses within a time are retransmitted. The authentication process starts with the application generating a non- zero random 32-bit value.

The TCP communication is encrypted using public key encryption of a session key. Communication is established with the requestor sending the Establish Encrypted Communication Message. The Public Encryption Key and Modulus Key (known as e and n in StringToPublicNED function) will be sent to the receiver. Even though these may be known from the trust anchor, they are sent to establish an encrypted session in the case where a trust anchor cannot be found. The receiver randomly generate a 64-bit sequence number and encrypt the high 32-bit and low 32-bit values using the public encryption keys. The encrypted sequence key then is sent back to the requestor in the Accept Encrypted Communication Message.

Both parties will use this sequence number as a session key for encrypting further communications in the Encrypted Data Chunk Message. The first Encrypted Data Chunk Message sent by the requestor will use the sequence number plus one, and each subsequent Encrypted Data Chunk Message will increment the sequence number by one. The first Encrypted Data Chunk Message sent by the receiver use the sequence number minus one, and each subsequent Encrypted Data Chunk Message will decrement the sequence number by one. The TCP messages 2 are encapsulated and encrypted inside Encrypted Data Chunk Messages, with no changes to the message contents. Messages that do not perfectly align to a 64 byte boundary are padded prior to encryption with “random” bytes.

